diff -rupN linux-sh4-orig/arch/sh/boards/mach-mb442/mach.c linux-sh4/arch/sh/boards/mach-mb442/mach.c
--- linux-sh4-orig/arch/sh/boards/mach-mb442/mach.c	2015-11-05 21:54:42.000000000 +0100
+++ linux-sh4/arch/sh/boards/mach-mb442/mach.c	2014-07-25 00:59:52.000000000 +0200
@@ -43,10 +43,10 @@ static void __init mb442_init_irq(void)
 	/* Set the ILC to route external interrupts to the the INTC */
 	/* Outputs 0-3 are the interrupt pins, 4-7 are routed to the INTC */
 	/* Inputs sys-irq2 and 3 are unused (pulled high) */
-	ilc_route_external(ILC_EXT_IRQ0, 4, 0);		/* SMC Ethernet */
-	ilc_route_external(ILC_EXT_IRQ1, 5, 0);		/* ATA */
-	ilc_route_external(ILC_EXT_IRQ2, 6, 0);		/* Unused */
-	ilc_route_external(ILC_EXT_MDINT, 7, 0);	/* STe100 PHY */
+//	ilc_route_external(ILC_EXT_IRQ0, 4, 0);		/* SMC Ethernet */
+	ilc_route_external(ILC_EXT_IRQ1, 5, 0);		/* NBOX LAN */
+//	ilc_route_external(ILC_EXT_IRQ2, 6, 0);		/* Unused */
+//	ilc_route_external(ILC_EXT_MDINT, 7, 0);	/* STe100 PHY */
 }
 
 void __init mb442_setup(char**);
diff -rupN linux-sh4-orig/arch/sh/boards/mach-mb442/setup.c linux-sh4/arch/sh/boards/mach-mb442/setup.c
--- linux-sh4-orig/arch/sh/boards/mach-mb442/setup.c	2015-11-05 21:54:42.000000000 +0100
+++ linux-sh4/arch/sh/boards/mach-mb442/setup.c	2014-07-25 00:59:52.000000000 +0200
@@ -18,18 +18,37 @@
 #include <linux/delay.h>
 #include <linux/spi/spi.h>
 #include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h> 
+#include <linux/stm/nand.h> 
+#include <linux/mtd/partitions.h> 
 #include <linux/mtd/physmap.h>
 #include <linux/stm/platform.h>
 #include <linux/stm/stx7100.h>
 #include <asm/irl.h>
-
-
-
-#define MB442_PIO_STE100P_RESET stm_gpio(2, 4)
-#define MB442_PIO_SMC91X_RESET stm_gpio(2, 6)
-#define MB442_PIO_FLASH_VPP stm_gpio(2, 7)
-
-
+#include <linux/bpa2.h>
+#include <linux/stm/emi.h>
+#include <linux/stm/gpio.h> 
+
+const char *LMI_VID_partalias[] = { "BPA2_Region1", "coredisplay-video", "gfx-memory", "v4l2-video-buffers", "v4l2-coded-video-buffers", NULL };
+
+const char *LMI_SYS_partalias[] = { "BPA2_Region0", "bigphysarea", NULL };
+
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+      {
+                .name  = "LMI_VID",
+                .start = 0x10800000,
+                .size  = 0x03800000,
+                .flags = 0,
+                .aka   = LMI_VID_partalias
+            },
+            {
+                .name  = "LMI_SYS",
+                .start = 0,
+                .size  = 0x01C00000,
+                .flags = 0,
+                .aka   = LMI_SYS_partalias
+            }
+        };
 
 void __init mb442_setup(char** cmdline_p)
 {
@@ -40,20 +59,19 @@ void __init mb442_setup(char** cmdline_p
 	stx7100_configure_asc(2, &(struct stx7100_asc_config) {
 			.hw_flow_control = 0,
 			.is_console = 1, });
-	stx7100_configure_asc(3, &(struct stx7100_asc_config) {
-			.hw_flow_control = 0,
-			.is_console = 0, });
+	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+
 }
 
 static struct resource mb442_smc91x_resources[] = {
 	[0] = {
-		.start	= 0x02000300,
-		.end	= 0x02000300 + 0xff,
+		.start	= 0x00c00000,
+		.end	= 0x00c3ffff,
 		.flags	= IORESOURCE_MEM,
 	},
 	[1] = {
-		.start	= IRL0_IRQ,
-		.end	= IRL0_IRQ,
+		.start	= IRL1_IRQ,
+		.end	= IRL1_IRQ,
 		.flags	= IORESOURCE_IRQ,
 	},
 };
@@ -64,53 +82,95 @@ static struct platform_device mb442_smc9
 	.num_resources	= ARRAY_SIZE(mb442_smc91x_resources),
 	.resource	= mb442_smc91x_resources,
 };
+/*
+static struct mtd_partition mb442_nand_flash_partitions[] = {
+	{
+		.name	= "rootfs",
+		.offset	= 0,
+		.size 	= 0x03c00000	//nand 64MB
+		//.size 	= 0x07c00000	//nand 128MB
+	}, {
+		.name	= "kernel",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= MTDPART_SIZ_FULL
+	},
+};
 
-static void mb442_set_vpp(struct map_info *info, int enable)
-{
-	gpio_set_value(MB442_PIO_FLASH_VPP, enable);
-}
+struct stm_nand_bank_data nand_bank_data = {
 
-static struct platform_device mb442_physmap_flash = {
-	.name		= "physmap-flash",
-	.id		= -1,
-	.num_resources	= 1,
-	.resource	= (struct resource[]) {
-		STM_PLAT_RESOURCE_MEM(0, 8*1024*1024),
+	.csn		= 1,
+	.nr_partitions	= ARRAY_SIZE(mb442_nand_flash_partitions),
+	.partitions	= mb442_nand_flash_partitions,
+	.options	= NAND_NO_AUTOINCR,
+	.timing_data	= &(struct stm_nand_timing_data) {
+	.sig_setup	= 40,		// times in ns 
+	.sig_hold	= 40,
+	.CE_deassert	= 0,
+	.WE_to_RBn	= 100,
+	.wr_on		= 0,
+	.wr_off		= 10,
+	.rd_on		= 0,
+	.rd_off		= 10,
+	.chip_delay	= 25,			// in us 
+},
+	.emi_withinbankoffset	= 0,
+};
+
+static struct platform_device mb442_nand_device = { 
+	.name		= "stm-nand-emi", 
+	.dev.platform_data = &(struct stm_plat_nand_emi_data){ 
+	.nr_banks	= 1,
+	.banks		= &nand_bank_data,
+	.emi_rbn_gpio	= stm_gpio(4, 5), 
 	},
-	.dev.platform_data = &(struct physmap_flash_data) {
-		.width		= 2,
-		.set_vpp	= mb442_set_vpp,
+};
+*/
+
+static struct mtd_partition nand_partitions[] = {
+	{
+		.name	= "rootfs",
+		.offset	= 0,
+		.size 	= 0x03c00000	//64MB
+		//.size 	= 0x07c00000	//128MB
+	}, {
+		.name	= "kernel",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= MTDPART_SIZ_FULL
 	},
 };
 
+static struct nand_config_data nbox_nand_config = {
+	.emi_bank		= 1,
+	.emi_withinbankoffset	= 0,
+
+	/* Timings for NAND512W3A */
+	.emi_timing_data = &(struct emi_timing_data) {
+		.rd_cycle_time	 = 40,		 /* times in ns */
+		.rd_oee_start	 = 0,
+		.rd_oee_end	 = 10,
+		.rd_latchpoint	 = 10,
+		.busreleasetime  = 0,
+
+		.wr_cycle_time	 = 40,
+		.wr_oee_start	 = 0,
+		.wr_oee_end	 = 10,
 
-static int mb442_phy_reset(void* bus)
-{
-	gpio_set_value(MB442_PIO_STE100P_RESET, 1);
-	udelay(1);
-	gpio_set_value(MB442_PIO_STE100P_RESET, 0);
-	udelay(1);
-	gpio_set_value(MB442_PIO_STE100P_RESET, 1);
-
-	return 1;
-}
+		.wait_active_low = 0,
+	},
 
-#define STMMAC_PHY_ADDR 14
-static int stmmac_phy_irqs[PHY_MAX_ADDR] = {
-	[STMMAC_PHY_ADDR] = IRL3_IRQ,
-};
-static struct stmmac_mdio_bus_data stmmac_mdio_bus = {
-	.bus_id = 0,
-	.phy_reset = mb442_phy_reset,
-	.phy_mask = 1,
-	.irqs = stmmac_phy_irqs,
+	.chip_delay		= 40,		/* time in us */
+	.mtd_parts		= nand_partitions,
+	.nr_parts		= ARRAY_SIZE(nand_partitions),
+	.rbn_port		= 4,
+	.rbn_pin		= 5
 };
 
 static struct platform_device *mb442_devices[] __initdata = {
 	&mb442_smc91x_device,
-	&mb442_physmap_flash,
+	//&mb442_nand_device,
 };
 
+
 static int __init mb442_device_init(void)
 {
 	stx7100_configure_sata();
@@ -120,8 +180,7 @@ static int __init mb442_device_init(void
 			.out1_enabled = 1, });
 
 	stx7100_configure_ssc_i2c(0, NULL);
-	stx7100_configure_ssc_spi(1, NULL);
-	stx7100_configure_ssc_i2c(2, NULL);
+	stx7100_configure_ssc_i2c(1, NULL);
 
 	stx7100_configure_usb();
 
@@ -130,32 +189,7 @@ static int __init mb442_device_init(void
 			.tx_enabled = 0,
 			.tx_od_enabled = 0, });
 
-	stx7100_configure_pata(&(struct stx7100_pata_config) {
-			.emi_bank = 3,
-			.pc_mode = 1,
-			.irq = IRL1_IRQ, });
-
-	gpio_request(MB442_PIO_FLASH_VPP, "Flash VPP");
-	gpio_direction_output(MB442_PIO_FLASH_VPP, 0);
-
-	gpio_request(MB442_PIO_STE100P_RESET, "STE100P reset");
-	gpio_direction_output(MB442_PIO_STE100P_RESET, 1);
-
-	stx7100_configure_ethernet(&(struct stx7100_ethernet_config) {
-			.mode = stx7100_ethernet_mode_mii,
-			.ext_clk = 0,
-			.phy_bus = 0,
-			.phy_addr = STMMAC_PHY_ADDR,
-			.mdio_bus_data = &stmmac_mdio_bus,
-		});
-
-	/* Reset the SMSC 91C111 Ethernet chip */
-	gpio_request(MB442_PIO_SMC91X_RESET, "SMC91x reset");
-	gpio_direction_output(MB442_PIO_SMC91X_RESET, 0);
-	udelay(1);
-	gpio_set_value(MB442_PIO_SMC91X_RESET, 1);
-	udelay(1);
-	gpio_set_value(MB442_PIO_SMC91X_RESET, 0);
+	stx7100_configure_nand(&nbox_nand_config);
 
 	return platform_add_devices(mb442_devices,
 			ARRAY_SIZE(mb442_devices));
diff -rupN linux-sh4-orig/drivers/ata/sata_stm.c linux-sh4/drivers/ata/sata_stm.c
--- linux-sh4-orig/drivers/ata/sata_stm.c	2015-11-05 21:54:44.000000000 +0100
+++ linux-sh4/drivers/ata/sata_stm.c	2014-07-25 01:00:14.000000000 +0200
@@ -871,6 +871,8 @@ static unsigned stm_sata_dma_irq(struct
 	} else if (readl(mmio + DMAC_RAWERR) & 1) {
 		ata_port_printk(ap, KERN_ERR, "DMA error asserted\n");
 	}
+	
+	else handled = 0;
 
 	return handled;
 
@@ -951,20 +953,20 @@ static irqreturn_t stm_sata_interrupt(in
 	struct ata_host *host = dev_instance;
 	unsigned int handled = 0;
 	unsigned int i;
-	struct stm_host_priv *hpriv = host->private_data;
 
 DPRINTK("ENTER\n");
 
 	spin_lock(&host->lock);
 
-	for (i = 0; i < host->n_ports; i++) {
-		if (hpriv->shared_dma_host_irq)
-			handled += stm_sata_dma_irq(host->ports[i]);
-		handled += stm_sata_host_irq(host->ports[i]);
+	for (i = 0; i < host->n_ports; i++) 
+	   {
+		handled += stm_sata_dma_irq(host->ports[i]);
+		if (!(handled)) handled += stm_sata_host_irq(host->ports[i]);
+		else handled = 0;
 	}
 
 	spin_unlock(&host->lock);
-
+	
 	return IRQ_RETVAL(handled);
 }
 
@@ -1178,6 +1180,26 @@ static int stm_sata_AHB_boot(struct devi
 	return 0;
 }
 
+static unsigned char stm_readb(const volatile void __iomem *addr)
+{
+	return readl(addr);
+}
+
+static unsigned short stm_readw(const volatile void __iomem *addr)
+{
+	return readl(addr);
+}
+
+static void stm_writeb(unsigned char b, volatile void __iomem *addr)
+{
+	writel(b, addr);
+}
+
+static void stm_writew(unsigned short b, volatile void __iomem *addr)
+{
+	writel(b, addr);
+}
+
 static int __devinit stm_sata_probe(struct platform_device *pdev)
 {
 	struct stm_plat_sata_data *sata_private_info = pdev->dev.platform_data;
@@ -1211,6 +1233,9 @@ static int __devinit stm_sata_probe(stru
 	if (!hpriv->device_state)
 		return -EBUSY;
 
+	if (!hpriv->device_state)
+		return -EBUSY; 
+
 	mem_res = platform_get_resource(pdev,IORESOURCE_MEM,0);
 	phys_base = mem_res->start;
 	phys_size = mem_res->end - mem_res->start + 1;
@@ -1251,9 +1276,11 @@ static int __devinit stm_sata_probe(stru
 	       hpriv->softsg ? "soft" : "hard");
 
 	if (sata_private_info->only_32bit) {
-		printk(KERN_ERR DRV_NAME " hardware doesn't support "
-			"byte/long ops, giving up\n");
-		return -EINVAL;
+		printk(KERN_DEBUG DRV_NAME " forcing all byte/word ops to long\n");
+		stm_ops.readb = stm_readb;
+		stm_ops.readw = stm_readw;
+		stm_ops.writeb = stm_writeb;
+		stm_ops.writew = stm_writew;
 	}
 
 	sata_rev = readl(mmio_base + SATA_VERSIONR);
diff -rupN linux-sh4-orig/drivers/char/lirc/lirc_stm.c linux-sh4/drivers/char/lirc/lirc_stm.c
--- linux-sh4-orig/drivers/char/lirc/lirc_stm.c	2015-11-05 21:54:44.000000000 +0100
+++ linux-sh4/drivers/char/lirc/lirc_stm.c	2014-07-25 01:00:02.000000000 +0200
@@ -882,7 +882,7 @@ static inline void lirc_stm_rx_reset_dat
 	rx.error = 0;
 	rx.off_rbuf = 0;
 	rx.sumUs = 0;
-	memset(rx.rbuf, 0, LIRC_STM_BUFSIZE);
+	memset(rx.rbuf, 0, (LIRC_STM_BUFSIZE*4));	//freebox
 }
 
 static void lirc_stm_rx_interrupt(int irq, void *dev_id)
@@ -1376,7 +1376,7 @@ static int lirc_stm_probe(struct platfor
 	 */
 
 	if ((rx.rbuf = (lirc_t *) devm_kzalloc(dev,
-					       LIRC_STM_BUFSIZE,
+					       (LIRC_STM_BUFSIZE*4),	//freebox
 					       GFP_KERNEL)) == NULL)
 		return -ENOMEM;
 
diff -rupN linux-sh4-orig/drivers/mtd/nand/plat_nand.c linux-sh4/drivers/mtd/nand/plat_nand.c
--- linux-sh4-orig/drivers/mtd/nand/plat_nand.c	2015-11-05 21:54:47.000000000 +0100
+++ linux-sh4/drivers/mtd/nand/plat_nand.c	2014-07-25 01:00:13.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
 #include <linux/mtd/partitions.h>
+#include <linux/stm/pio.h>
 
 struct plat_nand_data {
 	struct nand_chip	chip;
@@ -63,15 +64,17 @@ static int __devinit plat_nand_probe(str
 
 	data->mtd.name = dev_name(&pdev->dev);
 
-	data->chip.IO_ADDR_R = data->io_base;
-	data->chip.IO_ADDR_W = data->io_base;
+//	data->chip.IO_ADDR_R = data->io_base;
+//	data->chip.IO_ADDR_W = data->io_base;
+	data->chip.IO_ADDR_R = (void __iomem *)data->io_base;
+	data->chip.IO_ADDR_W = (void __iomem *)(data->io_base + 0x400000);
 	data->chip.cmd_ctrl = pdata->ctrl.cmd_ctrl;
 	data->chip.dev_ready = pdata->ctrl.dev_ready;
 	data->chip.select_chip = pdata->ctrl.select_chip;
 	data->chip.write_buf = pdata->ctrl.write_buf;
 	data->chip.read_buf = pdata->ctrl.read_buf;
 	data->chip.chip_delay = pdata->chip.chip_delay;
-	data->chip.options |= pdata->chip.options;
+	data->chip.options |= NAND_NO_AUTOINCR;//pdata->chip.options;
 
 	data->chip.read_buf = pdata->ctrl.read_buf;
 	data->chip.write_buf = pdata->ctrl.write_buf;
diff -rupN linux-sh4-orig/drivers/mtd/nand/stm_nand_emi.c linux-sh4/drivers/mtd/nand/stm_nand_emi.c
--- linux-sh4-orig/drivers/mtd/nand/stm_nand_emi.c	2015-11-05 21:54:47.000000000 +0100
+++ linux-sh4/drivers/mtd/nand/stm_nand_emi.c	2014-07-25 01:00:13.000000000 +0200
@@ -37,13 +37,14 @@
 #include <linux/stm/platform.h>
 #include <linux/stm/nand.h>
 #include <asm/dma.h>
+#include <linux/stm/pio.h>
 
 #ifdef CONFIG_MTD_PARTITIONS
 #include <linux/mtd/partitions.h>
 #endif
 
 #define NAME	"stm-nand-emi"
-
+struct stpio_pin *nand_ce_pin = NULL;
 /*
  * Private data for stm_emi_nand driver.  Concurrency and device locking
  * handled by MTD layers.
@@ -461,12 +462,24 @@ static void nand_cmd_ctrl_emi(struct mtd
 
 	if (ctrl & NAND_CTRL_CHANGE) {
 		if (ctrl & NAND_CLE) {
-			this->IO_ADDR_W = data->io_cmd;
-		} else if (ctrl & NAND_ALE) {
-			this->IO_ADDR_W = data->io_addr;
-		} else {
-			this->IO_ADDR_W = data->io_base;
+			this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (unsigned int)(1 << 17));
+		}
+		else {
+			this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(unsigned int)(1 << 17));
+		}
+
+		if (ctrl & NAND_ALE) {
+			this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W | (unsigned int)(1 << 16));
+		}
+		else {
+			this->IO_ADDR_W = (void *)((unsigned int)this->IO_ADDR_W & ~(unsigned int)(1 << 16));
 		}
+	if (ctrl & NAND_NCE) {
+		    stpio_set_pin(nand_ce_pin, 0); 
+			}
+			else {
+			stpio_set_pin(nand_ce_pin, 1); 
+		}	
 	}
 
 	if (cmd != NAND_CMD_NONE)
@@ -629,10 +642,10 @@ static struct stm_nand_emi * __init nand
 		goto out4;
 	}
 
-	data->io_addr = ioremap_nocache(data->emi_base | (1 << 18), 1);
+	data->io_addr = ioremap_nocache(data->emi_base | (1 << 16), 1);
 	if (!data->io_addr) {
 		printk(KERN_ERR NAME ": ioremap failed for io_addr 0x%08x\n",
-		       data->emi_base | (1 << 18));
+		       data->emi_base | (1 << 16));
 		res = -ENOMEM;
 		goto out5;
 	}
@@ -646,8 +659,8 @@ static struct stm_nand_emi * __init nand
 
 	tm = bank->timing_data;
 
-	data->chip.IO_ADDR_R = data->io_base;
-	data->chip.IO_ADDR_W = data->io_base;
+	data->chip.IO_ADDR_R = 0xA0400000;
+	data->chip.IO_ADDR_W = 0xA0800000;
 	data->chip.chip_delay = tm->chip_delay;
 	data->chip.cmd_ctrl = nand_cmd_ctrl_emi;
 
@@ -746,7 +759,7 @@ static int __init stm_nand_emi_probe(str
 			GFP_KERNEL);
 	if (!group)
 		return -ENOMEM;
-
+	nand_ce_pin = stpio_request_set_pin(3, 6, "nand_sel", STPIO_OUT, 0);
 	rbn_gpio = pdata->emi_rbn_gpio;
 	if (gpio_is_valid(rbn_gpio)) {
 		res = gpio_request(rbn_gpio, "nand_RBn");
diff -rupN linux-sh4-orig/drivers/net/smc91x.c linux-sh4/drivers/net/smc91x.c
--- linux-sh4-orig/drivers/net/smc91x.c	2015-11-05 21:54:48.000000000 +0100
+++ linux-sh4/drivers/net/smc91x.c	2014-07-25 01:00:03.000000000 +0200
@@ -234,7 +234,6 @@ static void PRINT_PKT(u_char *buf, int l
 	}								\
 } while (0)
 
-
 /*
  * this does a soft reset on the device
  */
@@ -269,6 +268,10 @@ static void smc_reset(struct net_device
 	SMC_SELECT_BANK(lp, 0);
 	SMC_SET_RCR(lp, RCR_SOFTRST);
 
+    	msleep(100); // d-mon
+    	SMC_SET_RCR(lp, RCR_CLEAR);
+    	msleep(60);
+
 	/*
 	 * Setup the Configuration Register
 	 * This is necessary because the CONFIG_REG is not affected
@@ -309,6 +312,8 @@ static void smc_reset(struct net_device
 	SMC_SET_RCR(lp, RCR_CLEAR);
 	SMC_SET_TCR(lp, TCR_CLEAR);
 
+    	udelay(5); // d-mon
+
 	SMC_SELECT_BANK(lp, 1);
 	ctl = SMC_GET_CTL(lp) | CTL_LE_ENABLE;
 
@@ -325,6 +330,8 @@ static void smc_reset(struct net_device
 
 	/* Reset the MMU */
 	SMC_SELECT_BANK(lp, 2);
+	udelay(5); // d-mon
+
 	SMC_SET_MMU_CMD(lp, MC_RESET);
 	SMC_WAIT_MMU_BUSY(lp);
 }
@@ -349,7 +356,9 @@ static void smc_enable(struct net_device
 	SMC_SET_MAC_ADDR(lp, dev->dev_addr);
 
 	/* now, enable interrupts */
-	mask = IM_EPH_INT|IM_RX_OVRN_INT|IM_RCV_INT;
+	//mask = IM_EPH_INT|IM_RX_OVRN_INT|IM_RCV_INT;
+	mask = IM_ERCV_INT|IM_ALLOC_INT|IM_RCV_INT | IM_MDINT; // d-mon
+
 	if (lp->version >= (CHIP_91100 << 4))
 		mask |= IM_MDINT;
 	SMC_SELECT_BANK(lp, 2);
@@ -1117,10 +1126,14 @@ static void smc_phy_configure(struct wor
 	 * Enable PHY Interrupts (for register 18)
 	 * Interrupts listed here are disabled
 	 */
+	smc_phy_read(dev, phyaddr, PHY_INT_REG); // d-mon
+
 	smc_phy_write(dev, phyaddr, PHY_MASK_REG,
 		PHY_INT_LOSSSYNC | PHY_INT_CWRD | PHY_INT_SSD |
 		PHY_INT_ESD | PHY_INT_RPOL | PHY_INT_JAB |
 		PHY_INT_SPDDET | PHY_INT_DPLXDET);
+	smc_phy_read(dev, phyaddr, PHY_INT_REG); // d-mon
+	smc_phy_read(dev, phyaddr, PHY_INT_REG); // d-mon
 
 	/* Configure the Receive/Phy Control register */
 	SMC_SELECT_BANK(lp, 0);
@@ -2354,7 +2367,11 @@ static int __devinit smc_drv_probe(struc
 		ret = -ENOMEM;
 		goto out_release_attrib;
 	}
-
+	
+	
+	platform_set_drvdata(pdev, ndev);
+	//ret = smc_probe(ndev, addr);
+	
 #ifdef CONFIG_ARCH_PXA
 	{
 		struct smc_local *lp = netdev_priv(ndev);
diff -rupN linux-sh4-orig/drivers/net/smc91x.h linux-sh4/drivers/net/smc91x.h
--- linux-sh4-orig/drivers/net/smc91x.h	2015-11-05 21:54:48.000000000 +0100
+++ linux-sh4/drivers/net/smc91x.h	2014-07-25 01:00:03.000000000 +0200
@@ -250,16 +250,19 @@ SMC_outw(u16 val, void __iomem *ioaddr,
  * to do a SMC_outl, which on a 16 bit bus translates into two 16 bit writes.
  * This bypasses the special logic which would prevent this also updating
  * this interrupt mask register. */
-#define SMC_CAN_USE_8BIT	1
+#define SMC_CAN_USE_8BIT	0
 #define SMC_CAN_USE_16BIT	1
 #define SMC_CAN_USE_32BIT	0
 #define SMC_CAN_USE_32BIT_DATA	1
-#define SMC_IO_SHIFT		0
+#define SMC_IO_SHIFT		14
+    
+    #undef  SMC_USE_PXA_DMA
+     
 #else
 #error Unknown board
 #endif
 
-#define SMC_NOWAIT		0
+#define SMC_NOWAIT		1
 #define SMC_IRQ_FLAGS		0
 
 #ifdef SMC_STEM_BS_MASK
diff -rupN linux-sh4-orig/drivers/stm/stx7100.c linux-sh4/drivers/stm/stx7100.c
--- linux-sh4-orig/drivers/stm/stx7100.c	2015-11-05 21:54:49.000000000 +0100
+++ linux-sh4/drivers/stm/stx7100.c	2014-07-25 00:59:54.000000000 +0200
@@ -26,6 +26,9 @@
 #include <linux/stm/stx7100.h>
 #include <asm/irq-ilc.h>
 
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/stm/pio.h>
 
 
 /* EMI resources ---------------------------------------------------------- */
@@ -125,11 +128,152 @@ void __init stx7100_configure_pata(struc
 
 
 
+/* NAND Resources ---------------------------------------------------------- */
+static void nand_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *this = mtd->priv;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+
+		if (ctrl & NAND_CLE)
+			this->IO_ADDR_W = (void *)
+				((unsigned int)this->IO_ADDR_W |
+				 (unsigned int)(1 << 17));
+		else
+			this->IO_ADDR_W = (void *)
+				((unsigned int)this->IO_ADDR_W &
+				 ~(unsigned int)(1 << 17));
+
+		if (ctrl & NAND_ALE)
+			this->IO_ADDR_W = (void *)
+				((unsigned int)this->IO_ADDR_W |
+				 (unsigned int)(1 << 16));
+		else
+			this->IO_ADDR_W = (void *)
+				((unsigned int)this->IO_ADDR_W &
+				 ~(unsigned int)(1 << 16));
+	}
+
+	if (ctrl & NAND_NCE)
+		stpio_request_set_pin(3,6,"nandready",STPIO_OUT,0);
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, this->IO_ADDR_W);
+}
+
+static void nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+
+	/* write buf up to 4-byte boundary */
+	while ((unsigned int)buf & 0x3) {
+		writeb(*buf++, chip->IO_ADDR_W);
+		len--;
+	}
+
+	writesl(chip->IO_ADDR_W, buf, len/4);
+
+	/* mop up trailing bytes */
+	for (i = (len & ~0x3); i < len; i++)
+		writeb(buf[i], chip->IO_ADDR_W);
+}
+
+static void nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+
+	/* read buf up to 4-byte boundary */
+	while ((unsigned int)buf & 0x3) {
+		*buf++ = readb(chip->IO_ADDR_R);
+		len--;
+	}
+
+	readsl(chip->IO_ADDR_R, buf, len/4);
+
+	/* mop up trailing bytes */
+	for (i = (len & ~0x3); i < len; i++)
+		buf[i] = readb(chip->IO_ADDR_R);
+}
+
+static const char *nand_part_probes[] = { "cmdlinepart", NULL };
+
+static struct stpio_pin *nand_RBn_pio = NULL;
+ 
+static int nand_device_ready(struct mtd_info *mtd) {
+ 
+        return stpio_get_pin(nand_RBn_pio);
+}
+
+static struct platform_device nand_flash[] = {
+	EMI_NAND_DEVICE(0),
+	EMI_NAND_DEVICE(1),
+	EMI_NAND_DEVICE(2),
+	EMI_NAND_DEVICE(3),
+	EMI_NAND_DEVICE(4),
+ };
+
+void __init stx7100_configure_nand(struct nand_config_data *data)
+{
+	unsigned int bank_base, bank_end;
+	unsigned int emi_bank = data->emi_bank;
+	unsigned long config[4];
+
+	struct platform_nand_data *nand_private_data =
+		nand_flash[emi_bank].dev.platform_data;
+
+        if (data->rbn_port >= 0) {
+                if (nand_RBn_pio == NULL) {
+                        nand_RBn_pio = stpio_request_pin(data->rbn_port, data->rbn_pin,
+                                         "nand_RBn", STPIO_IN);
+                }
+                if (nand_RBn_pio) {
+                        nand_private_data->ctrl.dev_ready = nand_device_ready;
+                }                           
+        }           
+
+	bank_base = emi_bank_base(emi_bank) + data->emi_withinbankoffset;
+	if (emi_bank == 4)
+		bank_end = 0x07ffffff;
+	else
+		bank_end = emi_bank_base(emi_bank+1) - 1;
+
+	printk(KERN_INFO "Configuring EMI Bank%d for NAND device\n", emi_bank);
+	emi_config_nand(data->emi_bank, data->emi_timing_data);
+	config[0] = 0x00300619;
+	config[1] = 0x8a230000;
+	config[2] = 0x8a130000;
+	config[3] = 0x00;
+	emi_bank_configure(1, config);
+
+	config[0] = 0x00300619;
+	config[1] = 0x8a230000;
+	config[2] = 0x8a230000;
+	config[3] = 0x00;
+	emi_bank_configure(2, config);
+
+	emi_config_pcmode(1, 0);
+	emi_config_pcmode(2, 0);
+
+	nand_flash[emi_bank].resource[0].start = bank_base;
+	nand_flash[emi_bank].resource[0].end = bank_end;
+
+	nand_private_data->chip.chip_delay = data->chip_delay;
+	nand_private_data->chip.partitions = data->mtd_parts;
+	nand_private_data->chip.nr_partitions = data->nr_parts;
+
+	platform_device_register(&nand_flash[emi_bank]);
+}
+
+
+
 /* FDMA resources --------------------------------------------------------- */
 
 static struct stm_plat_fdma_fw_regs stm_fdma_firmware_7100 = {
 	.rev_id    = 0x8000 + (0x000 << 2), /* 0x8000 */
 	.cmd_statn = 0x8000 + (0x010 << 2), /* 0x8040 */
+	.req_ctln  = 0x9780, 
 	.ptrn      = 0x8000 + (0x460 << 2), /* 0x9180 */
 	.cntn      = 0x8000 + (0x462 << 2), /* 0x9188 */
 	.saddrn    = 0x8000 + (0x463 << 2), /* 0x918c */
diff -rupN linux-sh4-orig/drivers/stm/stx7100_comms.c linux-sh4/drivers/stm/stx7100_comms.c
--- linux-sh4-orig/drivers/stm/stx7100_comms.c	2015-11-05 21:54:49.000000000 +0100
+++ linux-sh4/drivers/stm/stx7100_comms.c	2014-07-25 00:59:54.000000000 +0200
@@ -226,12 +226,12 @@ static struct stm_pad_config stx7100_ssc
 			STM_PAD_PIO_BIDIR_NAMED(2, 0, 1, "SCL"),
 			STM_PAD_PIO_BIDIR_NAMED(2, 1, 1, "SDA"),
 		},
-		.sysconfs_num = 2,
+		.sysconfs_num = 1,
 		.sysconfs = (struct stm_pad_sysconf []) {
 			/* SSC0_MUX_SEL = 0 (default assignment) */
 			STM_PAD_SYS_CFG(7, 1, 1, 0),
-			/* DVO_OUT_ON = 0 (SSC not DVO) */
-			STM_PAD_SYS_CFG(7, 10, 10, 0),
+		//	/* DVO_OUT_ON = 0 (SSC not DVO) */
+		//	STM_PAD_SYS_CFG(7, 10, 10, 0),
 		},
 	},
 	[1] = {
@@ -345,7 +345,7 @@ int __init stx7100_configure_ssc_i2c(int
 	BUG_ON(stx7100_ssc_configured[ssc]);
 	stx7100_ssc_configured[ssc] = 1;
 
-	stx7100_ssc_devices[ssc].name = "i2c-stm";
+	stx7100_ssc_devices[ssc].name = "i2c-st40";
 	stx7100_ssc_devices[ssc].id = i2c_busnum;
 
 	plat_data = stx7100_ssc_devices[ssc].dev.platform_data;
diff -rupN linux-sh4-orig/drivers/stm/stx7100_hispeed.c linux-sh4/drivers/stm/stx7100_hispeed.c
--- linux-sh4-orig/drivers/stm/stx7100_hispeed.c	2015-11-05 21:54:49.000000000 +0100
+++ linux-sh4/drivers/stm/stx7100_hispeed.c	2014-07-25 00:59:54.000000000 +0200
@@ -193,6 +193,12 @@ static int stx7100_usb_pad_claim(struct
 	stx7100_usb_pwr_gpio = stm_pad_gpio_request_output(state, "PWR", 1);
 	BUG_ON(stx7100_usb_pwr_gpio == STM_GPIO_INVALID);
 
+	//reset usb on boot - some DVB-T dongles (as102) need it to work properly.
+	gpio_set_value(stx7100_usb_pwr_gpio, 0);
+	mdelay(2000);
+	gpio_set_value(stx7100_usb_pwr_gpio, 1);
+	mdelay(600);
+
 	return 0;
 }
 
diff -rupN linux-sh4-orig/include/linux/libata.h linux-sh4/include/linux/libata.h
--- linux-sh4-orig/include/linux/libata.h	2015-11-05 21:54:51.000000000 +0100
+++ linux-sh4/include/linux/libata.h	2014-07-25 00:59:24.000000000 +0200
@@ -52,6 +52,7 @@
  * compile-time options: to be removed as soon as all the drivers are
  * converted to the new debugging mechanism
  */
+//#define ATA_DEBUG
 #undef ATA_DEBUG		/* debugging output */
 #undef ATA_VERBOSE_DEBUG	/* yet more debugging output */
 #undef ATA_IRQ_TRAP		/* define to ack screaming irqs */
@@ -884,8 +885,72 @@ struct ata_port_operations {
 	 * fields must be pointers.
 	 */
 	const struct ata_port_operations	*inherits;
+	
+	unsigned char (*readb)(const volatile void __iomem *addr);
+	unsigned short (*readw)(const volatile void __iomem *addr);
+	void (*writeb)(unsigned char b, volatile void __iomem *addr);
+	void (*writew)(unsigned short b, volatile void __iomem *addr);
 };
 
+static inline u8 sata_readb(struct ata_port *ap, const volatile void __iomem *addr)
+{
+	u8 r;
+	if (ap->ops->readb)
+		r = (ap->ops->readb)(addr);
+	else
+		r = readb(addr);
+
+	return r;
+}
+
+static inline u16 sata_readw(struct ata_port *ap, const volatile void __iomem *addr)
+{
+	u16 r;
+	if (ap->ops->readw)
+		r = (ap->ops->readw)(addr);
+	else
+		r = readw(addr);
+
+	return r;
+}
+
+static inline void sata_writeb(struct ata_port *ap, u8 b, volatile void __iomem *addr)
+{
+	if (ap->ops->writeb)
+		(ap->ops->writeb)(b, addr);
+	else
+		writeb(b, addr);
+}
+
+static inline void sata_writew(struct ata_port *ap, u16 b, volatile void __iomem *addr)
+{
+	if (ap->ops->writew)
+		(ap->ops->writew)(b, addr);
+	else
+		writew(b, addr);
+}
+
+#undef readb
+#define readb(a_)	sata_readb(ap, a_)
+#undef writeb
+#define writeb(v_,a_)	sata_writeb(ap, v_, a_)
+#undef readw
+#define readw(a_)	sata_readw(ap, a_)
+#undef writew
+#define writew(v_,a_)	sata_writew(ap, v_, a_)
+
+/* overwrite the original definition from io.h */
+#undef __raw_readb
+#define __raw_readb(a_)		readb(a_)
+#undef __raw_writeb
+#define __raw_writeb(v_,a_)	writeb(v_,a_)
+#undef __raw_readw
+#define __raw_readw(a_)		readw(a_)
+#undef __raw_writew
+#define __raw_writew(v_,a_)	writew(v_,a_)
+
+
+
 struct ata_port_info {
 	unsigned long		flags;
 	unsigned long		link_flags;
diff -rupN linux-sh4-orig/include/linux/stm/nand.h linux-sh4/include/linux/stm/nand.h
--- linux-sh4-orig/include/linux/stm/nand.h	2015-11-05 21:54:51.000000000 +0100
+++ linux-sh4/include/linux/stm/nand.h	2014-07-25 00:59:26.000000000 +0200
@@ -39,4 +39,52 @@ struct stm_nand_bank_data {
 	unsigned int		emi_withinbankoffset;
 };
 
+
+/* NAND configuration data */
+struct nand_config_data {
+	unsigned int emi_bank;			/* EMI Bank#			*/
+	unsigned int emi_withinbankoffset;	/* Offset within EMI Bank	*/
+	void *emi_timing_data;			/* Timing data for EMI config   */
+	void *mtd_parts;			/* MTD partition table		*/
+	unsigned int chip_delay;		/* Read busy time for NAND chip */
+	int nr_parts;				/* Number of partitions		*/
+	int rbn_port;				/*  # : 'nand_RBn' PIO port #   */
+						/* -1 : if unconnected		*/
+	int rbn_pin;			        /*      'nand_RBn' PIO pin      */
+						/* (assumes shared RBn signal   */
+						/*  for multiple chips)		*/
+};
+
+#define EMI_NAND_DEVICE(_id)							\
+{										\
+	.name		= "gen_nand",						\
+	.id		= _id,							\
+	.num_resources	= 1,							\
+	.resource	= (struct resource[]) {					\
+		{								\
+			.flags		= IORESOURCE_MEM,			\
+		}								\
+	},									\
+	.dev		= {							\
+		.platform_data	= &(struct platform_nand_data) {		\
+			.chip		=					\
+			{							\
+				.nr_chips		= 1,			\
+				.options		= NAND_NO_AUTOINCR,	\
+				.part_probe_types 	= nand_part_probes,	\
+			},							\
+			.ctrl		=					\
+			{							\
+				.cmd_ctrl		= nand_cmd_ctrl,	\
+				.write_buf		= nand_write_buf,	\
+				.read_buf		= nand_read_buf,	\
+			}							\
+		}								\
+	}									\
+}
+
+
+
+
+
 #endif /* __LINUX_STM_NAND_H */
diff -rupN linux-sh4-orig/include/linux/stm/stx7100.h linux-sh4/include/linux/stm/stx7100.h
--- linux-sh4-orig/include/linux/stm/stx7100.h	2015-11-05 21:54:51.000000000 +0100
+++ linux-sh4/include/linux/stm/stx7100.h	2014-07-25 00:59:26.000000000 +0200
@@ -91,5 +91,6 @@ struct stx7100_pata_config {
 };
 void stx7100_configure_pata(struct stx7100_pata_config *config);
 
+void stx7100_configure_nand(struct nand_config_data *config);
 
 #endif
diff -rupN linux-sh4-orig/drivers/mtd/nand/Kconfig linux-sh4/drivers/mtd/nand/Kconfig
--- linux-sh4-orig/drivers/mtd/nand/Kconfig	2015-11-05 21:54:47.000000000 +0100
+++ linux-sh4/drivers/mtd/nand/Kconfig	2014-07-25 01:00:13.000000000 +0200
@@ -497,6 +497,7 @@ config STM_NAND_BCH_DEBUG
 config MTD_NAND_STM_EMI
 	tristate "STMicroelectronics: EMI 'bit-banging'"
 	depends on MTD_NAND
+	depends on (CPU_SUBTYPE_STX7100)
 	help
 	  Enables the STMicroelectronics NAND driver for platforms in which the
 	  device is connected via an EMI bank.
diff -rupN linux-sh4-orig/sound/stm/Kconfig linux-sh4/sound/stm/Kconfig
--- linux-sh4-orig/sound/stm/Kconfig	2015-11-05 21:54:53.000000000 +0100
+++ linux-sh4/sound/stm/Kconfig	2014-07-25 01:00:23.000000000 +0200
@@ -23,11 +23,6 @@ config SND_STM_PCM_PLAYER
 	depends on SND_STM
 	default n
 
-config SND_STM_PCM_READER
-	tristate
-	depends on SND_STM
-	default n
-
 config SND_STM_SPDIF_PLAYER
 	tristate
 	depends on SND_STM
@@ -75,7 +70,6 @@ config SND_STM_FLI75XX
 	depends on SND_STM
 	default y if CPU_SUBTYPE_FLI75XX
 	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
 	select SND_STM_SPDIF_PLAYER
 	help
 		Select this to get ALSA driver for Freeman 510/520/530/540/560
@@ -89,7 +83,6 @@ config SND_STM_STX7100
 	depends on SND_STM
 	default y if CPU_SUBTYPE_STX7100
 	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
 	select SND_STM_SPDIF_PLAYER
 	select SND_STM_CONV_DAC_MEMORY_MAPPED
 	select SND_STM_CONV_I2S_TO_SPDIF
@@ -104,7 +97,6 @@ config SND_STM_STX7105
 	depends on SND_STM
 	default y if CPU_SUBTYPE_STX7105
 	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
 	select SND_STM_SPDIF_PLAYER
 	select SND_STM_CONV_DAC_MEMORY_MAPPED
 	select SND_STM_CONV_I2S_TO_SPDIF
@@ -119,7 +111,6 @@ config SND_STM_STX7108
 	depends on SND_STM
 	default y if CPU_SUBTYPE_STX7108
 	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
 	select SND_STM_SPDIF_PLAYER
 	select SND_STM_CONV_DAC_SYSCONF
 	select SND_STM_CONV_I2S_TO_SPDIF
@@ -134,7 +125,6 @@ config SND_STM_STX7111
 	depends on SND_STM
 	default y if CPU_SUBTYPE_STX7111
 	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
 	select SND_STM_SPDIF_PLAYER
 	select SND_STM_CONV_DAC_MEMORY_MAPPED
 	select SND_STM_CONV_I2S_TO_SPDIF
@@ -149,7 +139,6 @@ config SND_STM_STX7141
 	depends on SND_STM
 	default y if CPU_SUBTYPE_STX7141
 	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
 	select SND_STM_SPDIF_PLAYER
 	select SND_STM_CONV_DAC_MEMORY_MAPPED
 	select SND_STM_CONV_I2S_TO_SPDIF
@@ -164,7 +153,6 @@ config SND_STM_STX7200
 	depends on SND_STM
 	default y if CPU_SUBTYPE_STX7200
 	select SND_STM_PCM_PLAYER
-	select SND_STM_PCM_READER
 	select SND_STM_SPDIF_PLAYER
 	select SND_STM_CONV_DAC_MEMORY_MAPPED
 	select SND_STM_CONV_I2S_TO_SPDIF
diff -rupN linux-sh4-orig/include/linux/tty.h linux-sh4/include/linux/tty.h
--- linux-sh4-orig/include/linux/tty.h	2015-11-16 09:31:40.486197896 +0100
+++ linux-sh4/include/linux/tty.h	2015-11-16 09:32:37.290197256 +0100
@@ -162,6 +162,7 @@ struct tty_bufhead {
 #define C_CLOCAL(tty)	_C_FLAG((tty), CLOCAL)
 #define C_CIBAUD(tty)	_C_FLAG((tty), CIBAUD)
 #define C_CRTSCTS(tty)	_C_FLAG((tty), CRTSCTS)
+#define C_CMSPAR(tty)   _C_FLAG((tty), CMSPAR)
 
 #define L_ISIG(tty)	_L_FLAG((tty), ISIG)
 #define L_ICANON(tty)	_L_FLAG((tty), ICANON)
diff -rupN linux-sh4-orig/drivers/usb/serial/ch341.c linux-sh4/drivers/usb/serial/ch341.c
--- linux-sh4-orig/drivers/usb/serial/ch341.c	2015-11-16 07:50:45.302266109 +0100
+++ linux-sh4/drivers/usb/serial/ch341.c	2015-11-16 07:55:48.294262696 +0100
@@ -359,6 +359,7 @@ static void ch341_set_termios(struct tty
 	struct ch341_private *priv = usb_get_serial_port_data(port);
 	unsigned baud_rate;
 	unsigned long flags;
+	unsigned int par_flags;
 
 	dbg("ch341_set_termios()");
 
@@ -381,9 +382,33 @@ static void ch341_set_termios(struct tty
 
 	/* Unimplemented:
 	 * (cflag & CSIZE) : data bits [5, 8]
-	 * (cflag & PARENB) : parity {NONE, EVEN, ODD}
 	 * (cflag & CSTOPB) : stop bits [1, 2]
 	 */
+	/* CH340 doesn't appear to support variable stop bits or data bits */
+	if (C_PARENB(tty)) {
+		if (C_PARODD(tty)) {
+			if (tty->termios->c_cflag & CMSPAR) {
+				dev_dbg(&port->dev, "parity = mark\n");
+				par_flags = 0xeb;
+			} else {
+				dev_dbg(&port->dev, "parity = odd\n");
+				par_flags = 0xcb;
+			}
+		} else {
+			if (tty->termios->c_cflag & CMSPAR) {
+				dev_dbg(&port->dev, "parity = space\n");
+				par_flags = 0xfb;
+			} else {
+				dev_dbg(&port->dev, "parity = even\n");
+				par_flags = 0xdb;
+			}
+		}
+	} else {
+		dev_dbg(&port->dev, "parity = none\n");
+		par_flags = 0xc3;
+	}
+	ch341_control_out(port->serial->dev, 0x9a, 0x2518, par_flags);
+
 }
 
 static void ch341_break_ctl(struct tty_struct *tty, int break_state)
diff -rupN linux-sh4-orig/drivers/usb/serial/ch34x.c linux-sh4/drivers/usb/serial/ch34x.c
--- linux-sh4-orig/drivers/usb/serial/ch34x.c	2015-11-16 08:54:25.350223075 +0100
+++ linux-sh4/drivers/usb/serial/ch34x.c	2015-11-16 10:26:00.000000000 +0100
@@ -0,0 +1,1266 @@
+// 2013.7
+//********************************************
+//**  Copyright  (C)  WCH  2002-2013    ******
+//**  Web:  http://www.winchiphead.com  ******
+//********************************************
+//**  Driver for USB to serial adaptor CH34X**
+//**  GCC                                   **
+//********************************************
+
+// Support linux kernel version 2.6.25 and later
+//
+
+#include <linux/version.h>
+#ifndef KERNEL_VERSION
+#define	KERNEL_VERSION(ver, rel, seq)	((ver << 16) | (rel << 8) | (seq))
+#endif
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/tty.h>
+#include <linux/tty_driver.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+//#include <linux/uaccess.h>
+#include <linux/usb.h>
+#include <linux/usb/serial.h>
+
+#define DRIVER_DESC		"WCH CH34x USB to serial adaptor driver"
+#define DRIVER_AUTHOR	"<tech@wch.cn>"
+
+#define CH34x_VENDOR_ID		0x1A86
+#define CH340_PRODUCT_ID	0x7523
+#define CH341_PRODUCT_ID	0x5523
+
+#define CH34x_CLOSING_WAIT	(30 * HZ)
+
+#define CH34x_BUF_SIZE		1024
+#define CH34x_TMP_BUF_SIZE	1024
+
+//Vendor define
+#define VENDOR_WRITE_TYPE		0x40
+#define VENDOR_READ_TYPE		0xC0
+
+#define VENDOR_READ				0x95
+#define VENDOR_WRITE			0x9A
+#define VENDOR_SERIAL_INIT		0xA1
+#define VENDOR_MODEM_OUT		0xA4
+#define VENDOR_VERSION			0x5F
+
+//For CMD 0xA4
+#define UART_CTS		0x01
+#define UART_DSR		0x02
+#define UART_RING		0x04
+#define UART_DCD		0x08
+#define CONTROL_OUT		0x10
+#define CONTROL_DTR		0x20
+#define	CONTROL_RTS		0x40
+
+//Uart state
+#define UART_STATE			0x00
+#define UART_OVERRUN_ERROR	0x01
+#define UART_BREAK_ERROR	//no define
+#define UART_PARITY_ERROR	0x02
+#define UART_FRAME_ERROR	0x06
+#define UART_RECV_ERROR		0x02
+#define UART_STATE_TRANSIENT_MASK	0x07
+
+//Port state
+#define PORTA_STATE		0x01
+#define PORTB_STATE		0x02
+#define PORTC_STATE		0x03
+
+//CH34x Baud Rate
+#define CH34x_BAUDRATE_FACTOR	1532620800
+#define CH34x_BAUDRATE_DIVMAX	3
+
+#define DEBUG_CH34x
+#undef  DEBUG_CH34x
+
+#ifdef DEBUG_CH34x
+#define dbg_ch34x( format, arg... )		\
+	printk( KERN_DEBUG "%d: " format "\n", __LINE__, ##arg )
+#else
+#define dbg_ch34x( format, arg... )		\
+do{									\
+	if(0)							\
+		printk(KERN_DEBUG "%d: " format "\n", __LINE__, ##arg);	\
+} while (0)
+#endif
+
+#ifdef DEBUG_CH34x
+#define err_ch34x( format, arg... )		\
+	printk(KERN_ERR KBUILD_MODNAME ": " format "\n", ##arg)
+#else
+#define err_ch34x( format, arg... )   \
+do{								\
+	if(0)						\
+	printk( KERN_ERR KBUILD_MODNAME ": " format "\n", ##arg)\
+}while(0)						
+#endif
+
+// For debug
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,7,1))
+static int debug = 1;
+#endif
+
+struct ch34x_buf {
+	unsigned int buf_size;
+	char *buf_buf;
+	char *buf_get;
+	char *buf_put;
+};
+
+struct ch34x_private {
+	spinlock_t	lock;	//access lock
+	struct ch34x_buf	*buf;
+	int	write_urb_in_use;
+	unsigned baud_rate;
+	wait_queue_head_t	delta_msr_wait;
+	u8	line_control;
+	u8	line_status;
+	u8	termios_initialized;
+};
+
+static struct usb_device_id	id_table [] = {
+	{ USB_DEVICE(CH34x_VENDOR_ID, CH340_PRODUCT_ID) },
+	{ USB_DEVICE(CH34x_VENDOR_ID, CH341_PRODUCT_ID) },
+	{ } //End
+};
+MODULE_DEVICE_TABLE( usb, id_table );
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,2))
+static struct usb_driver ch34x_driver = {
+	.name		   = "ch34x",
+	.probe		   = usb_serial_probe,
+	.disconnect	   = usb_serial_disconnect,
+	.id_table	   = id_table,
+	.suspend	   = usb_serial_suspend,
+	.resume		   = usb_serial_resume,
+	.no_dynamic_id = 1,
+	.supports_autosuspend = 1,
+};
+#endif
+
+// ch34x_buf_alloc
+// Allocate a circular buffer and all associated memory
+static struct ch34x_buf *ch34x_buf_alloc( unsigned int size )
+{
+	struct ch34x_buf *pb;
+
+	if( size == 0 )
+		return NULL;
+
+	pb = kmalloc( sizeof(struct ch34x_buf), GFP_KERNEL );
+	if( pb == NULL )
+		return NULL;
+
+	pb->buf_buf = kmalloc( size, GFP_KERNEL );
+	if( pb->buf_buf == NULL ) {
+		kfree(pb);
+		return NULL;
+	}
+
+	pb->buf_size = size;
+	pb->buf_get = pb->buf_put = pb->buf_buf;
+
+	return pb;
+}
+
+// ch34x_buf_free
+// Free the buffer and all associated memory
+static void ch34x_buf_free( struct ch34x_buf *pb )
+{
+	if( pb ) {
+		kfree( pb->buf_buf );
+		kfree( pb );
+	}
+}
+
+// ch34x_buf_clear
+// Clear out all data in the circular buffer
+static void ch34x_buf_clear( struct ch34x_buf *pb )
+{
+	if( pb != NULL ) 
+		pb->buf_get = pb->buf_put;
+	// equivalent to a get of all data available
+}
+
+// ch34x_buf_data_avail
+// Return the number of bytes of data available in he circular buffer
+static unsigned int ch34x_buf_data_avail( struct ch34x_buf *pb )
+{
+	if( pb == NULL )
+		return 0;
+
+	return ((pb->buf_size + pb->buf_put - pb->buf_get) % pb->buf_size );
+}
+
+// ch34x_buf_space_avail
+// Return the number of bytes of space available in the circular
+static unsigned int ch34x_buf_space_avail( struct ch34x_buf *pb )
+{
+	if( pb == NULL )
+		return 0;
+
+	return ((pb->buf_size + pb->buf_get - pb->buf_put - 1) % pb->buf_size );
+}
+
+// ch34x_buf_put
+// Copy data from a user buffer and put it into the circular buffer.
+// Restrict to the amount of space available
+// Return the number of bytes copied
+static unsigned int ch34x_buf_put( struct ch34x_buf *pb,
+		const char *buf, unsigned int count )
+{
+	unsigned int len;
+
+	if( pb == NULL )
+		return 0;
+
+	len = ch34x_buf_space_avail(pb);
+	if( count > len )
+		count = len;
+	else if( count == 0 )
+		return 0;
+
+	len = pb->buf_buf + pb->buf_size - pb->buf_put;
+	if( count > len ) {
+		memcpy( pb->buf_put, buf, len );
+		memcpy( pb->buf_buf, buf+len, count - len );
+		pb->buf_put = pb->buf_buf + count - len;
+	}
+	else {
+		memcpy( pb->buf_put, buf, count );
+		if( count < len )
+			pb->buf_put += count;
+		else if( count == len )
+			pb->buf_put = pb->buf_buf;
+	}
+
+	return count;
+}
+
+static unsigned int ch34x_buf_get( struct ch34x_buf *pb,
+		char *buf, unsigned int count )
+{
+	unsigned int len;
+
+	if( pb == NULL )
+		return 0;
+
+	len = ch34x_buf_data_avail(pb);
+	if( count > len )
+		count = len;
+	else if( count == 0 )
+		return 0;
+
+	len = pb->buf_buf + pb->buf_size - pb->buf_get;
+	if( count > len ) {
+		memcpy( buf, pb->buf_get, len );
+		memcpy( buf+len, pb->buf_buf, count - len );
+		pb->buf_get = pb->buf_buf + count - len;
+	}
+	else {
+		memcpy( buf, pb->buf_get, count );
+		if( count < len )
+			pb->buf_get += count;
+		else if( count == len )
+			pb->buf_get = pb->buf_buf;
+	}
+
+	return count;
+}
+
+static int ch34x_vendor_read( __u8 request,
+		__u16 value,
+		__u16 index,
+		struct usb_serial *serial,
+		unsigned char *buf,
+		__u16 len )
+{
+	int retval;
+
+	retval = usb_control_msg( serial->dev, usb_rcvctrlpipe(serial->dev, 0), 
+			request, VENDOR_READ_TYPE, value, index, buf, len, 1000 );
+	dbg_ch34x("0x%x:0x%x:0x%x:0x%x %d - %d", 
+			VENDOR_READ_TYPE, request, value, index, retval, len );
+
+	return retval;
+}
+
+static int ch34x_vendor_write( __u8 request,
+		__u16 value,
+		__u16 index,
+		struct usb_serial *serial,
+		unsigned char *buf,
+		__u16 len )
+{
+	int retval;
+
+	retval = usb_control_msg( serial->dev, 
+			usb_sndctrlpipe(serial->dev, 0),
+			request,
+			VENDOR_WRITE_TYPE,
+			value, index, buf, len, 1000 );
+
+	return retval;
+}
+
+static int set_control_lines( struct usb_serial *serial,
+		u8 value )
+{
+	int retval;
+
+	retval = ch34x_vendor_write( VENDOR_MODEM_OUT, (unsigned short)value, 
+			0x0000, serial, NULL, 0x00 );
+	dbg_ch34x("%s - value=%d, retval=%d", __func__, value, retval );
+
+	return retval;
+}
+
+static int ch34x_get_baud_rate( unsigned int baud_rate,
+		unsigned char *a, unsigned char *b )
+{
+	unsigned long factor = 0;
+	short divisor = 0;
+
+	if( !baud_rate )
+		return -EINVAL;
+
+	factor = (CH34x_BAUDRATE_FACTOR / baud_rate);
+	divisor = CH34x_BAUDRATE_DIVMAX;
+
+	while( (factor > 0xfff0) && divisor ) {
+		factor >>= 3;
+		divisor --;
+	}
+
+	if( factor > 0xfff0 )
+		return -EINVAL;
+
+	factor = 0x10000 - factor;
+	*a = (factor & 0xff00) >> 8;
+	*b = divisor;
+
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static void ch34x_set_termios( struct tty_struct *tty,
+		struct usb_serial_port *port, struct ktermios *old_termios )
+{
+#else
+static void ch34x_set_termios( struct usb_serial_port *port,
+		struct ktermios *old_termios )
+{
+	struct tty_struct *tty = port->tty;
+#endif
+	struct usb_serial *serial = port->serial;	
+	struct ch34x_private *priv = usb_get_serial_port_data(port);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,1)) //sure
+	struct ktermios *termios = &tty->termios;
+#else
+	struct ktermios *termios = tty->termios;
+#endif
+	unsigned int baud_rate;
+	unsigned int cflag;
+	unsigned long flags;
+	u8 control;
+
+	unsigned char divisor = 0;
+	unsigned char reg_count = 0;
+	unsigned char factor = 0;
+	unsigned char reg_value = 0;
+	unsigned short value = 0;
+	unsigned short index = 0;
+
+	dbg_ch34x("%s - port:%d", __func__, port->number);
+	
+	spin_lock_irqsave( &priv->lock, flags );
+	if( !priv->termios_initialized ) {
+		*(termios) = tty_std_termios;
+		termios->c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+		termios->c_ispeed = 9600;
+		termios->c_ospeed = 9600;
+		priv->termios_initialized = 1;
+	}
+	spin_unlock_irqrestore( &priv->lock, flags );
+
+	/*
+	 * The ch34x is reported to lose bytes if you change serial setting
+	 * even to the same vaules as before. Thus we actually need to filter 
+	 * in this specific case.
+	 */
+	if( !tty_termios_hw_change(termios, old_termios) )
+		return;
+
+	cflag = termios->c_cflag;
+	dbg_ch34x("%s (%d) cflag=0x%x\n", __func__, port->number, cflag );
+
+	// Get the byte size
+	switch( cflag & CSIZE )
+	{
+		case CS5:
+			reg_value |= 0x00;
+			break;
+		case CS6:
+			reg_value |= 0x01;
+			break;
+		case CS7:
+			reg_value |= 0x02;
+			break;
+		case CS8:
+			reg_value |= 0x03;
+			break;
+		default:
+			reg_value |= 0x03;
+			break;
+	}
+	dbg_ch34x("%s - data bits = %d", __func__, reg_value + 0x05 );
+
+	// Figure out the stop bits 
+	if( cflag & CSTOPB ) {
+		reg_value |= 0x04;
+		dbg_ch34x("%s - stop bits = 2", __func__);
+	}
+	else 
+		dbg_ch34x("%s - stop bits = 1", __func__);
+
+	// Determine the parity
+	if( cflag & PARENB )
+		if( cflag & PARODD ) {
+			reg_value |= (0x08 | 0x00);
+			dbg_ch34x("%s - parity = odd", __func__);
+		}
+		else {
+			reg_value |= (0x08 | 0x10);
+			dbg_ch34x("%s - parity = even", __func__);
+		}
+	else
+		dbg_ch34x("%s - parity = none", __func__);
+
+	// Determine the baud rate
+	baud_rate = tty_get_baud_rate( tty );
+	dbg_ch34x("%s = baud_rate = %d", __func__, baud_rate);	
+	ch34x_get_baud_rate( baud_rate, &factor, &divisor );	
+	dbg_ch34x("----->>>> baud_rate = %d, factor:0x%x, divisor:0x%x",
+				baud_rate, factor, divisor );	
+
+	//enable SFR_UART RX and TX
+	reg_value |= 0xc0;
+	//enable SFR_UART Control register and timer
+	reg_count |= 0x9c;
+
+	value |= reg_count;
+	value |= (unsigned short)reg_value << 8;
+	index |= 0x80 | divisor;
+	index |= (unsigned short)factor << 8;
+	ch34x_vendor_write( VENDOR_SERIAL_INIT, value, index, serial, NULL, 0 );
+
+	// change control lines if we are switching to or from B0
+	spin_lock_irqsave( &priv->lock, flags ); 
+	control = priv->line_control;
+	if( (cflag & CBAUD) == B0 )
+		priv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);
+	else
+		priv->line_control |= (CONTROL_DTR | CONTROL_RTS);
+
+	if( control != priv->line_control ) {
+		control = priv->line_control;
+		spin_unlock_irqrestore( &priv->lock, flags );
+		set_control_lines( serial, control );
+	}
+	else
+		spin_unlock_irqrestore( &priv->lock, flags );
+
+	if( cflag & CRTSCTS )
+		ch34x_vendor_write( VENDOR_WRITE, 0x2727, 0x0101, serial, NULL, 0);
+
+	// FIXME: Need to read back resulting baud rate
+	if( baud_rate )
+		tty_encode_baud_rate(tty, baud_rate, baud_rate);
+
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,3)) 
+static int ch34x_tiocmget( struct tty_struct *tty )
+{
+	struct usb_serial_port *port = tty->driver_data;
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static int ch34x_tiocmget( struct tty_struct *tty,
+		struct file *filp )
+{
+	struct usb_serial_port *port = tty->driver_data;
+#else
+static int ch34x_tiocmget( struct usb_serial_port *port,
+		struct file *filp )
+{
+#endif
+	struct ch34x_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	unsigned int mcr;
+	/*unsigned int msr;*/
+	unsigned int retval;
+
+	dbg_ch34x("%s - port:%d", __func__, port->number);
+
+	if( !usb_get_intfdata( port->serial->interface) ) 
+		return -ENODEV;
+
+	spin_lock_irqsave( &priv->lock, flags );
+	mcr = priv->line_control;
+	spin_unlock_irqrestore( &priv->lock, flags );
+
+	retval = ((mcr & CONTROL_DTR) ? TIOCM_DTR : 0) |
+			 ((mcr & CONTROL_RTS) ? TIOCM_RTS : 0) |
+			 ((mcr & UART_CTS) ? TIOCM_CTS : 0) |
+			 ((mcr & UART_DSR) ? TIOCM_DSR : 0) |
+			 ((mcr & UART_RING) ? TIOCM_RI : 0) |
+			 ((mcr & UART_DCD) ? TIOCM_CD : 0);
+
+	dbg_ch34x("%s - retval=0x%x", __func__, retval);
+
+	return retval;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32) && \
+		LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27) )
+static void ch34x_close( struct tty_struct *tty,
+		struct usb_serial_port *port, struct file *filp )
+{
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32) )
+static void ch34x_close( struct usb_serial_port *port )
+{
+	struct tty_struct *tty = port->port.tty;
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+static void ch34x_close( struct usb_serial_port *port, 
+		struct file *filp )
+{
+	struct tty_struct *tty = port->tty;
+#endif
+	struct ch34x_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	unsigned int c_cflag;
+	int bps;
+	long timeout;
+	wait_queue_t wait;
+
+	dbg_ch34x("%s - port:%d", __func__, port->number);
+	
+	// wait for data do drain from the buffer
+	spin_lock_irqsave( &priv->lock, flags );
+	timeout = CH34x_CLOSING_WAIT;
+	init_waitqueue_entry( &wait, current );
+	add_wait_queue( &tty->write_wait, &wait );
+	for(;;) {
+		set_current_state( TASK_INTERRUPTIBLE );
+		if( ch34x_buf_data_avail(priv->buf) == 0 || timeout == 0 || 
+				signal_pending(current) || port->serial->disconnected )
+			break;
+		spin_unlock_irqrestore( &priv->lock, flags );
+		timeout = schedule_timeout( timeout );
+		spin_lock_irqsave( &priv->lock, flags );
+	}
+	set_current_state( TASK_RUNNING );
+	remove_wait_queue( &tty->write_wait, &wait );
+	// clear out any remaining data in the buffer
+	ch34x_buf_clear( priv->buf );
+	spin_unlock_irqrestore( &priv->lock, flags );
+
+	bps = tty_get_baud_rate( tty );
+	if( bps > 1200 ) 
+		timeout = max( (HZ * 2560) / bps, HZ / 10 );
+	else
+		timeout = 2 * HZ;
+	schedule_timeout_interruptible(timeout);
+
+	// shutdown our urbs
+	usb_kill_urb(port->interrupt_in_urb);
+	usb_kill_urb(port->read_urb);
+	usb_kill_urb(port->write_urb);
+	/*usb_serial_generic_close(port, filp);*/
+
+	if( tty ) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,1)) //sure
+		c_cflag = tty->termios.c_cflag;
+#else
+		c_cflag = tty->termios->c_cflag;
+#endif
+		if( c_cflag & HUPCL ) {
+			// drop DTR and RTS
+			spin_lock_irqsave( &priv->lock, flags );
+			priv->line_control = 0;
+			spin_unlock_irqrestore( &priv->lock, flags );
+			set_control_lines( port->serial, 0 );
+		}
+	}
+}
+
+// kernel version 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32) \
+		&& LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static int ch34x_open( struct tty_struct *tty,
+		struct usb_serial_port *port, struct file *filp )
+{
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
+static int ch34x_open( struct tty_struct *tty,
+		struct usb_serial_port *port )
+{
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+static int ch34x_open( struct usb_serial_port *port,
+		struct file *filp )
+{
+	struct tty_struct *tty = port->tty;
+#endif
+	struct ktermios tmp_termios;
+	struct usb_serial *serial = port->serial;
+	int retval;
+
+	dbg_ch34x("%s - port:%d", __func__, port->number );
+
+	usb_clear_halt( serial->dev, port->write_urb->pipe );
+	usb_clear_halt( serial->dev, port->read_urb->pipe );
+
+	if( tty ) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		ch34x_set_termios( tty, port, &tmp_termios );
+#else
+		ch34x_set_termios( port, &tmp_termios );
+#endif
+	}
+
+	dbg_ch34x("%s - submit read urb", __func__); 
+	port->read_urb->dev = serial->dev; 
+	retval = usb_submit_urb( port->read_urb, GFP_KERNEL );
+	if(retval) {
+		dev_err( &port->dev, "%s - failed submit read urb,error %d\n", 
+				__func__, retval );
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32) && \
+		LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27) )
+		ch34x_close(tty, port, NULL);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
+		ch34x_close(port);
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+		ch34x_close(port, filp);
+#endif
+		goto err_out;
+	}
+
+	dbg_ch34x("%s - submit interrupt urb", __func__ );
+	port->interrupt_in_urb->dev = serial->dev; 
+	retval = usb_submit_urb( port->interrupt_in_urb, GFP_KERNEL );
+	if(retval) {
+		dev_err( &port->dev, "%s - failed submit interrupt urb,error %d\n", 
+				__func__, retval );
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32) && \
+		LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27) )
+		ch34x_close(tty, port, NULL);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
+		ch34x_close(port);
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+		ch34x_close(port, filp);
+#endif
+		goto err_out;
+	}
+
+err_out:
+	return retval;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,3))
+static int ch34x_tiocmset( struct tty_struct *tty,
+		unsigned int set, unsigned int clear )
+{
+	struct usb_serial_port *port = tty->driver_data;
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static int ch34x_tiocmset( struct tty_struct *tty,
+		struct file *filp, unsigned int set, unsigned int clear )
+{
+	struct usb_serial_port *port = tty->driver_data;
+#else
+static int ch34x_tiocmset( struct usb_serial_port *port,
+		struct file *filp, unsigned int set, unsigned int clear )
+{
+#endif
+	struct ch34x_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	/*unsigned int mcr = priv->line_control;*/
+	u8 control;
+
+	dbg_ch34x("%s - port:%d", __func__, port->number);
+
+	if( !usb_get_intfdata(port->serial->interface) ) 
+		return -ENODEV;
+
+	spin_lock_irqsave( &priv->lock, flags );
+	if( set & TIOCM_RTS )
+		priv->line_control |= CONTROL_RTS;
+	if( set & TIOCM_DTR )
+		priv->line_control |= CONTROL_DTR;
+	if( clear & TIOCM_RTS )
+		priv->line_control &= ~CONTROL_RTS;
+	if( clear & TIOCM_DTR )
+		priv->line_control &= ~CONTROL_DTR;
+	control = priv->line_control;
+	spin_unlock_irqrestore( &priv->lock, flags );
+
+	return set_control_lines( port->serial, control );
+}
+
+static int wait_modem_info( struct usb_serial_port *port,
+		unsigned int arg )
+{
+	struct ch34x_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+	unsigned int prevstatus;
+	unsigned int status;
+	unsigned int changed;
+
+	dbg_ch34x("%s -port:%d", __func__, port->number);
+
+	spin_lock_irqsave( &priv->lock, flags );
+	prevstatus = priv->line_status;
+	spin_unlock_irqrestore( &priv->lock, flags );
+
+	while(1) {
+		interruptible_sleep_on( &priv->delta_msr_wait );
+		// see if a signal did it
+		if( signal_pending(current) ) 
+			return -ERESTARTSYS;
+
+		spin_lock_irqsave( &priv->lock, flags );
+		status = priv->line_status;
+		spin_unlock_irqrestore( &priv->lock, flags );
+
+		changed = prevstatus ^ status;
+
+		if( ((arg & TIOCM_RNG) && (changed & UART_RING)) ||
+			((arg & TIOCM_DSR) && (changed & UART_DSR))  ||
+			((arg & TIOCM_CD)  && (changed & UART_DCD))  ||
+			((arg & TIOCM_CTS) && (changed & UART_CTS)) )
+			return 0;
+
+		prevstatus = status;
+	}
+
+	// Not reatched
+	return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,3)) 
+static int ch34x_ioctl( struct tty_struct *tty,
+		unsigned int cmd, unsigned long arg )
+{
+	struct usb_serial_port *port = tty->driver_data;
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static int ch34x_ioctl( struct tty_struct *tty, 
+		struct file *filp, unsigned int cmd, unsigned long arg )
+{
+	struct usb_serial_port *port = tty->driver_data;
+#else
+static int ch34x_ioctl( struct usb_serial_port *port,
+		struct file *filp, unsigned int cmd, unsigned long arg )
+{
+	//struct usb_serial_port *port = tty->driver_data;
+#endif
+	dbg_ch34x("%s - port:%d, cmd=0x%04x", __func__, port->number, cmd);
+
+	switch(cmd)
+	{
+		// Note here 
+		case TIOCMIWAIT:
+			dbg_ch34x("%s - port:%d TIOCMIWAIT", __func__, port->number);
+			return wait_modem_info(port, arg);
+		default:
+			dbg_ch34x("%s not supported=0x%04x", __func__, cmd);
+			break;
+	}
+
+	return -ENOIOCTLCMD;
+}
+
+static void ch34x_send( struct usb_serial_port *port )
+{
+	int count;
+	int retval;
+	struct ch34x_private *priv = usb_get_serial_port_data( port );
+	unsigned long flags;
+
+	dbg_ch34x("%s - port:%d", __func__, port->number );
+
+	spin_lock_irqsave( &priv->lock, flags );
+	if( priv->write_urb_in_use ) {
+		spin_unlock_irqrestore( &priv->lock, flags );
+		return;
+	}
+
+	count = ch34x_buf_get( priv->buf, port->write_urb->transfer_buffer,
+			port->bulk_out_size );
+	if( count == 0 ) {
+		spin_unlock_irqrestore( &priv->lock, flags );
+		return;
+	}
+
+	priv->write_urb_in_use = 1;
+	spin_unlock_irqrestore( &priv->lock, flags );
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,1))
+	usb_serial_debug_data( &port->dev, __func__, count,
+			port->write_urb->transfer_buffer );
+#else
+	usb_serial_debug_data( debug, &port->dev, __func__, count,
+			port->write_urb->transfer_buffer );
+#endif
+
+	port->write_urb->transfer_buffer_length = count;
+	port->write_urb->dev = port->serial->dev;
+	retval = usb_submit_urb( port->write_urb, GFP_ATOMIC );
+	if( retval ) {
+		dev_err( &port->dev, "%s - failed submitting write urb,error %d\n"
+				, __func__, retval );
+		priv->write_urb_in_use = 0;
+		// reschedule ch34x_send
+	}
+
+	usb_serial_port_softint( port ); 
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static int ch34x_write( struct tty_struct *tty, 
+		struct usb_serial_port *port, const unsigned char *buf, int count )
+#else
+static int ch34x_write( struct usb_serial_port *port,
+		const unsigned char *buf, int count )
+#endif
+{
+	struct ch34x_private *priv = usb_get_serial_port_data(port);
+	unsigned long flags;
+
+	dbg_ch34x("%s - port:%d, %d bytes", __func__, port->number, count);
+
+	if( !count )
+		return count;
+
+	spin_lock_irqsave( &priv->lock, flags );
+	count = ch34x_buf_put( priv->buf, buf, count ); 
+	spin_unlock_irqrestore( &priv->lock, flags );
+
+	ch34x_send(port);
+
+	return count;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static int ch34x_write_room( struct tty_struct *tty )
+{
+	struct usb_serial_port *port = tty->driver_data;
+#else
+static int ch34x_write_room( struct usb_serial_port *port )
+{
+#endif
+	struct ch34x_private *priv = usb_get_serial_port_data( port );
+	int room = 0;
+	unsigned long flags;
+
+	dbg_ch34x("%s - port:%d", __func__, port->number );
+
+	spin_lock_irqsave( &priv->lock, flags );
+	room = ch34x_buf_space_avail( priv->buf );
+	spin_unlock_irqrestore( &priv->lock, flags );
+
+	dbg_ch34x("%s - room:%d", __func__, room );
+	return room;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+static int ch34x_chars_in_buffer( struct tty_struct *tty )
+{
+	struct usb_serial_port *port = tty->driver_data;
+#else
+static int ch34x_chars_in_buffer( struct usb_serial_port *port )
+{
+#endif
+	struct ch34x_private *priv = usb_get_serial_port_data(port);
+	int chars = 0;
+	unsigned long flags;
+
+	dbg_ch34x("%s - port:%d", __func__, port->number );
+
+	spin_lock_irqsave( &priv->lock, flags );
+	chars = ch34x_buf_data_avail( priv->buf );
+	spin_unlock_irqrestore( &priv->lock, flags );
+
+	dbg_ch34x("%s - chars:%d", __func__, chars );
+
+	return chars;
+}
+
+static int ch34x_attach( struct usb_serial *serial )
+{
+	struct ch34x_private *priv; 
+	int i;
+	char buf[8];
+
+	dbg_ch34x("%s", __func__);
+
+	for( i = 0; i < serial->num_ports; ++i ) {
+		priv = kzalloc( sizeof(struct ch34x_private), GFP_KERNEL );
+		if( !priv )
+			goto cleanup;
+		spin_lock_init( &priv->lock );
+		priv->buf = ch34x_buf_alloc( CH34x_BUF_SIZE );
+		if( priv->buf == NULL ) {
+			kfree( priv );
+			goto cleanup;
+		}
+		init_waitqueue_head( &priv->delta_msr_wait );
+		usb_set_serial_port_data( serial->port[i], priv );
+	}
+
+	ch34x_vendor_read( VENDOR_VERSION, 0x0000, 0x0000,
+			serial, buf, 0x02 );
+	ch34x_vendor_write( VENDOR_SERIAL_INIT, 0x0000, 0x0000,
+			serial, NULL, 0x00 );
+	ch34x_vendor_write( VENDOR_WRITE, 0x1312, 0xD982, 
+			serial, NULL, 0x00 );
+	ch34x_vendor_write( VENDOR_WRITE, 0x0F2C, 0x0004,
+			serial, NULL, 0x00 );
+	ch34x_vendor_read( VENDOR_READ, 0x2518, 0x0000,
+			serial, buf, 0x02 );
+	ch34x_vendor_write( VENDOR_WRITE, 0x2727, 0x0000,
+			serial, NULL, 0x00 );
+	ch34x_vendor_write( VENDOR_MODEM_OUT, 0x009F, 0x0000,
+			serial, NULL, 0x00 );
+
+	return 0;
+
+cleanup:
+	for( --i; i >= 0; --i ) {
+		priv = usb_get_serial_port_data( serial->port[i] );
+		ch34x_buf_free( priv->buf );
+		kfree( priv );
+		usb_set_serial_port_data( serial->port[i], NULL );
+	}
+
+	return -ENOMEM;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32))
+static void ch34x_shutdown( struct usb_serial *serial )
+{
+	struct ch34x_private *priv;
+	int i;
+
+	dbg_ch34x("%s", __func__);
+
+	for( i = 0; i < serial->num_ports; ++i ) {
+		priv = usb_get_serial_port_data( serial->port[i] );
+		if( priv ) {
+			ch34x_buf_free( priv->buf );
+			kfree( priv );
+			usb_set_serial_port_data( serial->port[i], NULL );
+		}
+	}
+}
+#endif
+
+static void ch34x_update_line_status( struct usb_serial_port *port,
+		unsigned char *data, unsigned int actual_length )
+{
+	struct ch34x_private *priv = usb_get_serial_port_data( port );
+	unsigned long flags;
+	u8 length = UART_STATE + 0x04;
+
+	if( actual_length < length )
+		return;
+
+	// Save off the uart status for others to look at
+	spin_lock_irqsave( &priv->lock, flags );
+	priv->line_status = data[UART_STATE];
+	priv->line_control = data[PORTB_STATE];
+	spin_unlock_irqrestore( &priv->lock, flags );
+	wake_up_interruptible( &priv->delta_msr_wait );
+}
+
+static void ch34x_read_int_callback( struct urb *urb )
+{
+	struct usb_serial_port *port = (struct usb_serial_port *)urb->context; 
+	unsigned char *data = urb->transfer_buffer;
+	unsigned int actual_length = urb->actual_length;
+	int status = urb->status;
+	int retval;
+
+	dbg_ch34x("%s port:%d", __func__, port->number );
+
+	switch( status ) {
+		case 0: //success
+			break;
+		case -ECONNRESET:
+		case -ENOENT:
+		case -ESHUTDOWN: //this urb is terminated, clean up
+			dbg_ch34x("%s - urb shutting down with status:%d", __func__, status );
+			return;
+		default:
+			dbg_ch34x("%s - nonzero urb status received:%d", __func__, status );
+			goto exit;
+	}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,1))
+	usb_serial_debug_data( &port->dev, __func__,
+			urb->actual_length, urb->transfer_buffer );
+#else
+	usb_serial_debug_data( debug, &port->dev, 
+			__func__, urb->actual_length, urb->transfer_buffer );
+#endif
+
+	ch34x_update_line_status( port, data, actual_length );
+
+exit:
+	retval = usb_submit_urb( urb, GFP_ATOMIC ); 
+	if( retval ) 
+		dev_err( &urb->dev->dev, "%s - usb_submit_urb failed with result %d\n", 
+				__func__, retval );
+}
+
+static void ch34x_read_bulk_callback( struct urb *urb )
+{
+	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct ch34x_private *priv = usb_get_serial_port_data( port );
+	struct tty_struct *tty;
+	unsigned char *data = urb->transfer_buffer;
+	unsigned long flags;
+	int i;
+	int retval;
+	int status = urb->status;
+	u8 line_status;
+	char tty_flag;
+
+	dbg_ch34x("%s - port:%d", __func__, port->number );
+	if( status ) {
+		dbg_ch34x("%s - urb status=%d", __func__, status );
+		if( status == -EPROTO ) {
+			// CH34x mysteriously fails with -EPROTO reschedule the read
+			dbg_ch34x("%s - caught -EPROTO, resubmitting the urb", __func__);
+			urb->dev = port->serial->dev;
+			retval = usb_submit_urb( urb, GFP_ATOMIC );
+			if( retval ) {
+				dev_err( &urb->dev->dev, 
+						"%s - failed resubmitting read urb, error %d\n",
+						__func__, retval );
+				return;
+			}
+		}
+
+		dbg_ch34x("%s - unable to handle the error, exiting.", __func__);
+		return;
+	}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,1))
+	usb_serial_debug_data( &port->dev, __func__,
+			urb->actual_length, data );
+#else
+	usb_serial_debug_data( debug, &port->dev, 
+			__func__, urb->actual_length, data );
+#endif
+
+	// get tty_flag from status
+	tty_flag = TTY_NORMAL;
+
+	spin_lock_irqsave( &priv->lock, flags );
+	line_status = priv->line_status;
+	priv->line_status &= ~UART_STATE_TRANSIENT_MASK;
+	spin_unlock_irqrestore( &priv->lock, flags );
+	wake_up_interruptible( &priv->delta_msr_wait );
+
+	// break takes precedence over parity, 
+	// which takes precedence over framing errors
+	if( line_status & UART_PARITY_ERROR )
+		tty_flag = TTY_PARITY;
+	else if( line_status & UART_OVERRUN_ERROR )
+		tty_flag = TTY_OVERRUN;
+	else if( line_status & UART_FRAME_ERROR )
+		tty_flag = TTY_FRAME;
+	dbg_ch34x("%s - tty_flag=%d", __func__, tty_flag);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+	tty = port->port.tty; 
+#else
+	tty = port->tty;
+#endif
+	if( tty && urb->actual_length ) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,1))
+		tty_buffer_request_room( tty->port, urb->actual_length + 1);
+#else
+		tty_buffer_request_room( tty, urb->actual_length + 1 );
+#endif
+		// overrun is special, not associated with a char
+		if( line_status & UART_OVERRUN_ERROR )
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,1))
+			tty_insert_flip_char( tty->port, 0, TTY_OVERRUN );
+#else 
+			tty_insert_flip_char( tty, 0, TTY_OVERRUN ); 
+#endif
+		for( i = 0; i < urb->actual_length; ++i )
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,1))
+			tty_insert_flip_char( tty->port, data[i], tty_flag );
+#else
+			tty_insert_flip_char( tty, data[i], tty_flag );
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,1))
+		tty_flip_buffer_push( tty->port );
+#else
+		tty_flip_buffer_push( tty );
+#endif
+	}
+
+	//Schedule the next read _if_ we are still open
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
+	if( port->open_count ) 
+#endif
+	{
+		urb->dev = port->serial->dev;
+		retval = usb_submit_urb( urb, GFP_ATOMIC );
+		if( retval ) 
+			dev_err( &urb->dev->dev, 
+					"%s - fialed resubmitting read urb, error %d\n", 
+					__func__, retval );
+	}
+
+	return;
+}
+
+static void ch34x_write_bulk_callback( struct urb *urb )
+{
+	struct usb_serial_port *port = (struct usb_serial_port *)urb->context;
+	struct ch34x_private *priv = usb_get_serial_port_data(port);
+	int retval;
+	int status = urb->status;
+
+	dbg_ch34x("%s - port:%d", __func__, port->number );
+
+	switch( status ) {
+		case 0: //success
+			break;
+		case -ECONNRESET:
+		case -ENOENT:
+		case -ESHUTDOWN:
+			// this urb is terminated, clean up
+			dbg_ch34x("%s - urb shutting down with status:%d", __func__, status);
+			priv->write_urb_in_use = 0;
+			return;
+		default:
+			// error in the urb, so we have to resubmit it
+			dbg_ch34x("%s - Overflow in write", __func__);
+			dbg_ch34x("%s - nonzero write bulk status received:%d", __func__, status);
+			port->write_urb->transfer_buffer_length = 1;
+			port->write_urb->dev = port->serial->dev;
+			retval = usb_submit_urb(port->write_urb, GFP_ATOMIC);
+			if( retval )
+				dev_err( &urb->dev->dev, 
+						"%s - failed resubmitting write urv, error:%d\n",
+						__func__, retval );
+			else 
+				return;
+	}
+
+	priv->write_urb_in_use = 0;
+
+	// send any buffered data
+	ch34x_send(port);
+}
+
+static struct usb_serial_driver	ch34x_device = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "ch34x",
+	},
+	.id_table	= id_table,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,1))
+	.usb_driver	= &ch34x_driver,
+#endif
+	.num_ports		= 1,
+	.open			= ch34x_open,
+	.close			= ch34x_close,
+	.write			= ch34x_write,
+	.ioctl			= ch34x_ioctl,
+	.set_termios	= ch34x_set_termios,
+	.tiocmget		= ch34x_tiocmget,
+	.tiocmset		= ch34x_tiocmset,
+	.read_bulk_callback  = ch34x_read_bulk_callback,
+	.read_int_callback   = ch34x_read_int_callback,
+	.write_bulk_callback = ch34x_write_bulk_callback,
+	.write_room     = ch34x_write_room,
+	.chars_in_buffer = ch34x_chars_in_buffer,
+	.attach			= ch34x_attach,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32) )
+	.shutdown		= ch34x_shutdown,
+#endif
+};
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,5)) 
+static struct usb_serial_driver *const serial_driver [] = {
+	&ch34x_device, NULL
+};
+#endif
+
+
+static int __init ch34x_init(void)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,5)) 
+	int retval = 0;
+
+	retval = usb_serial_register( &ch34x_device );
+	if( retval ) {
+		goto err_usb_serial_register;
+	}
+	retval = usb_register( &ch34x_driver );
+	if( retval ) {
+		goto err_usb_register;
+	}
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32))
+	info( DRIVER_DESC );
+#endif
+	return 0;
+
+err_usb_register:
+	usb_deregister( &ch34x_driver );
+err_usb_serial_register:
+	usb_serial_deregister( &ch34x_device );
+	return retval;
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,1))
+	return usb_serial_register_drivers( serial_driver, 
+			KBUILD_MODNAME, id_table );
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,5) && \
+		LINUX_VERSION_CODE < KERNEL_VERSION(3,5,1))
+	return usb_serial_register_drivers(&ch34x_driver, serial_driver);
+#endif
+}
+
+static void __exit ch34x_exit(void)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,5))
+	usb_deregister( &ch34x_driver );
+	usb_serial_deregister( &ch34x_device );
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,1))
+	usb_serial_deregister_drivers( serial_driver );
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,5) && \
+		LINUX_VERSION_CODE < KERNEL_VERSION(3,5,1))
+	usb_serial_deregister_drivers(&ch34x_driver, serial_driver);
+#endif
+}
+
+module_init( ch34x_init );
+module_exit( ch34x_exit );
+
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
diff -rupN linux-sh4-orig/drivers/usb/serial/Kconfig linux-sh4/drivers/usb/serial/Kconfig
--- linux-sh4-orig/drivers/usb/serial/Kconfig	2015-11-16 08:45:12.618229302 +0100
+++ linux-sh4/drivers/usb/serial/Kconfig	2015-11-16 08:50:55.926225434 +0100
@@ -92,6 +92,15 @@ config USB_SERIAL_CH341
 	  To compile this driver as a module, choose M here: the
 	  module will be called ch341.
 
+config USB_SERIAL_CH34X
+	tristate "USB Winchiphead CH34X Single Port Serial Driver"
+	help
+	  Say Y here if you want to use a Winchiphead CH34X single port
+	  USB to serial adapter. New version.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ch34x.
+
 config USB_SERIAL_WHITEHEAT
 	tristate "USB ConnectTech WhiteHEAT Serial Driver"
 	select USB_EZUSB
diff -rupN linux-sh4-orig/drivers/usb/serial/Makefile linux-sh4/drivers/usb/serial/Makefile
--- linux-sh4-orig/drivers/usb/serial/Makefile	2015-11-16 08:45:26.666229144 +0100
+++ linux-sh4/drivers/usb/serial/Makefile	2015-11-16 08:49:17.898226539 +0100
@@ -15,6 +15,7 @@ obj-$(CONFIG_USB_SERIAL_AIRCABLE)		+= ai
 obj-$(CONFIG_USB_SERIAL_ARK3116)		+= ark3116.o
 obj-$(CONFIG_USB_SERIAL_BELKIN)			+= belkin_sa.o
 obj-$(CONFIG_USB_SERIAL_CH341)			+= ch341.o
+obj-$(CONFIG_USB_SERIAL_CH34X)			+= ch34x.o
 obj-$(CONFIG_USB_SERIAL_CP210X)			+= cp210x.o
 obj-$(CONFIG_USB_SERIAL_CYBERJACK)		+= cyberjack.o
 obj-$(CONFIG_USB_SERIAL_CYPRESS_M8)		+= cypress_m8.o
